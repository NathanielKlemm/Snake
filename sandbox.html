<html>
<head>
<title>Sandbox</title>
<style>
body { text-align: center; }
canvas { background:#2040C0; }
</style>
</head>
<body>
<canvas id="canvas" width="512px" height="512px"></canvas>
<script>
var canvas = document.getElementById("canvas"),
	context = canvas.getContext("2d"),
	gridSize = 32, //number of rows/columns in the (square) grid;
//note that the grid's origin is the center of the canvas, so the edges are all half a column/row
	cellSize = canvas.width/gridSize, //height/width in pixels of a (square) cell
	cells = []; //(gridSize+1)x(gridSize+1) array of cells;
//cells[0][0] is x=-16,y=-16; cells[16][16] is x=0,y=0; cells[32][32] is x=16,y=16

function Vector(xValue,yValue) {
	this.x = xValue;
	this.y = yValue;
}

function Cell(isWall) {
	//this.position = position;
	this.isWall = isWall;
}

for (var col = 0; col <= gridSize; col++) {
	cells[col] = [];
	for (var row = 0; row <= gridSize; row++) {
		cells[col][row] = new Cell(false);
	}
}

for (var w = 0; w < 14; w++) {
	cells[gridSize/2-5][gridSize/2+11-w].isWall = true;
}

for (var row = 0; row <= gridSize; row++) {
	cells[0][row].isWall = true;
	cells[gridSize][row].isWall = true;
}

for (var col = 0; col <= gridSize; col++) {
	cells[col][0].isWall = true;
	cells[col][gridSize].isWall = true;
}

function Player(startPosition,currentPosition,radius) {
	this.start = startPosition;
	this.position = currentPosition;
	this.size = radius;
	this.draw = function () {
		context.beginPath();
		context.arc(this.position.x*cellSize,this.position.y*cellSize,this.size,0,2*Math.PI,true);
		context.stroke();
	}
	this.move = function(direction) {
		if (direction == 37) {
			if (this.position.x > -gridSize/2 + 1 && !cells[this.position.x + gridSize/2 - 1][this.position.y + gridSize/2].isWall) {
				this.position.x -= 1;
			}
		}
		else if (direction == 38) {
			if (this.position.y < gridSize/2 - 1   && !cells[this.position.x + gridSize/2][this.position.y + gridSize/2 + 1].isWall) {
				this.position.y += 1;
			}
		}
		else if (direction == 39) {
			if (this.position.x < gridSize/2 - 1  && !cells[this.position.x + gridSize/2 + 1][this.position.y + gridSize/2].isWall) {
				this.position.x += 1;
			}
		}
		else if (direction == 40) {
			if (this.position.y > -gridSize/2 + 1 && !cells[this.position.x + gridSize/2][this.position.y + gridSize/2 - 1].isWall) {
				this.position.y -= 1;
			}
		}
		draw();
	}
}

function drawGrid() {		
	for (var c = 1; c < gridSize; c++) {
		context.beginPath();
		context.moveTo(c*cellSize - canvas.width/2,canvas.height/2);
		context.lineTo(c*cellSize - canvas.width/2,-canvas.height/2);
		context.stroke();
	}
	for (var r = 1; r < gridSize; r++) {
		context.beginPath();
		context.moveTo(-canvas.width/2,r*cellSize - canvas.height/2);
		context.lineTo(canvas.height/2,r*cellSize - canvas.height/2);
		context.stroke();
	}
}

function drawWalls() {
	for (col = -gridSize/2; col <= gridSize/2; col++) {
		for (row = -gridSize/2; row <= gridSize/2; row++) {
			if (cells[col+gridSize/2][row+gridSize/2].isWall) {
				context.beginPath();
				context.moveTo((col - 0.5)*cellSize, (row + 0.5)*cellSize); //upper left corner
				context.lineTo((col - 0.5)*cellSize, (row - 0.5)*cellSize); //lower left corner
				context.lineTo((col + 0.5)*cellSize, (row - 0.5)*cellSize); //lower right corner
				context.lineTo((col + 0.5)*cellSize, (row + 0.5)*cellSize); //upper right corner
				context.fill();
			}
		}
	}
}

pos = new Vector(0,0);
player1 = new Player(pos,pos,cellSize/2);

context.transform(1,0,0,-1,canvas.width/2,canvas.height/2);

function keyDown(event) {
	var key = event.keyCode;
	if (key <= 40 && key >= 37) {
		player1.move(key);
	}
}

document.addEventListener("keydown",keyDown,false);

function draw() {
	context.clearRect(-canvas.width/2,canvas.height/2,canvas.width,-canvas.height);
	//drawGrid();
	player1.draw();
	drawWalls();
}

draw();

</script>
</body>
</html>